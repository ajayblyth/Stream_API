üîπ Basic Stream API Questions

INTERMEDITAE OPERATIONS:
 The operations that are performed on a stream and they return a stream are called intermediate operations.
 e.g dinstinct(), sort(), map(), filter() etc.

 TERMINAL OPERATIONS:
 they dont return a stream , even just void.

 Example:
 forEach returns void.
 .reduce returns an integer.

 example of intermediate:

 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;

 public class StreamMethodsExample {
     public static void main(String[] args) {
         List<String> words = Arrays.asList("apple", "banana", "Apple", "cherry", "blueberry", "avocado", "banana", "apricot");

         // 1. filter() - Keep words that start with 'a'
         List<String> filteredWords = words.stream()
                 .filter(word -> word.startsWith("a") || word.startsWith("A")
                 .collect(Collectors.toList());
         System.out.println("Filtered (start with 'a'): " + filteredWords); // [apple, Apple, avocado, apricot]

         // 2. map() - Convert all words to uppercase
         List<String> mappedWords = words.stream()
                 .map(String::toUpperCase)
                 .collect(Collectors.toList());
         System.out.println("Mapped (toUpperCase): " + mappedWords); // [APPLE, BANANA, APPLE, CHERRY, BLUEBERRY, AVOCADO, BANANA, APRICOT]

         // 3. flatMap() - Flatten nested lists
         List<List<String>> nestedList = Arrays.asList(
                 Arrays.asList("apple", "banana"),
                 Arrays.asList("cherry", "avocado")
         );
         List<String> flatMappedList = nestedList.stream()
                 .flatMap(List::stream)
                 .collect(Collectors.toList());
         System.out.println("FlatMapped: " + flatMappedList); // [apple, banana, cherry, avocado]

         // 4. distinct() - Remove duplicate words
         List<String> distinctWords = words.stream()
                 .distinct()
                 .collect(Collectors.toList());
         System.out.println("Distinct (Remove Duplicates): " + distinctWords); // [apple, banana, cherry, blueberry, avocado, apricot]

         // 5. sorted() - Sort words in alphabetical order
         List<String> sortedWords = words.stream()
                 .sorted()
                 .collect(Collectors.toList());
         System.out.println("Sorted (Alphabetically): " + sortedWords); // [apple, apple, apricot, avocado, banana, banana, blueberry, cherry]

          // 5.1 sorted() - Sort words in reverse alphabetical order
                 List<String> reverseSortedWords = words.stream()
                         .sorted(Comparator.reverseOrder()) // Sort in descending order
                         .collect(Collectors.toList());

                 System.out.println("Sorted (Reverse Alphabetically): " + reverseSortedWords);
                 // Output: [cherry, blueberry, banana, banana, apple, apple, apricot, avocado]

         // 6. peek() - Debugging intermediate stream
         List<String> peekedWords = words.stream()
                 .peek(word -> System.out.println("Processing: " + word))
                 .map(String::toUpperCase)
                 .collect(Collectors.toList());
         System.out.println("Peeked (Debugging Step): " + peekedWords); // Shows words being processed

         // 7. limit() - Get first 3 words only
         List<String> limitedWords = words.stream()
                 .limit(3)
                 .collect(Collectors.toList());
         System.out.println("Limited (First 3 elements): " + limitedWords); // [apple, banana, apple]

         // 8. skip() - Skip first 2 words
         List<String> skippedWords = words.stream()
                 .skip(2)
                 .collect(Collectors.toList());
         System.out.println("Skipped (First 2 elements): " + skippedWords); // [apple, cherry, blueberry, avocado, banana, apricot]
    //9 split()

    String sentence = "what should i say, i dont know anything please continue without me";

            List<String> words = Arrays.asList(sentence.split(" ")); // Split sentence into words

            words.stream()
                    .filter(word -> word.startsWith("w") || word.startsWith("W")) // Filter words starting with 'w' or 'W'
                    .forEach(System.out::println);

     }
 }



-----------------------------------------------------------------------------------

WHY IS FUNCTIONAL PROGRAMMING CONSIDERED LAZY?

Functional programming (FP) is lazy because it delays computation until it is actually needed. This concept is known as lazy evaluation.
Instead of executing every function immediately, FP constructs a promise to execute it later when required.


example: ‚úî The filter() function does not execute immediately. It only runs when forEach() (a terminal operation) is called.
because of this performance is better as we are performing operations only when needed

 ----------------------------------------------------------------------------------------------


 1Ô∏è‚É£ Static Method Reference (ClassName::staticMethod)
 üëâ Used when referencing a static method of a class.
 üëâ No need to create an object of the class.

 ‚úÖ Example:

 class Utility {
     public static String toUpperCase(String str) {
         return str.toUpperCase();
     }
 }

 public class StaticMethodReference {
     public static void main(String[] args) {
         List<String> words = List.of("java", "spring", "hibernate");

         // Using static method reference
         List<String> upperCaseWords = words.stream()
                                            .map(Utility::toUpperCase) // Static method reference
                                            .collect(Collectors.toList());

         System.out.println(upperCaseWords);
     }
 }


 Utility::toUpperCase is a reference to a static method.
 It does not require an object of Utility.
 Syntax: ClassName::staticMethod.

 2Ô∏è‚É£ Non-Static (Instance) Method Reference (object::instanceMethod)
 üëâ Used when referencing an instance (non-static) method of a particular object.
 üëâ Requires an object to call the method.

 ‚úÖ Example:

 class Printer {
     public String printWithExclamation(String str) {
         return str + "!";
     }
 }

 public class InstanceMethodReference {
     public static void main(String[] args) {
         List<String> words = List.of("Hello", "World", "Java");

         Printer printer = new Printer(); // Creating an object

         // Using instance method reference
         words.forEach(printer::printWithExclamation); // Non-static method reference
     }
 }
 üîπ Key Points:
 printer::printWithExclamation is a reference to an instance method.
 Requires an object (printer) to call the method.
 Syntax: object::instanceMethod.

 3Ô∏è‚É£ Non-Static Method Reference on a Class (ClassName::instanceMethod)
 üëâ Used when referencing an instance method but without a specific object.
 üëâ The method will be called on each element of the stream.

 ‚úÖ Example:

 public class InstanceMethodRefOnClass {
     public static void main(String[] args) {
         List<String> words = List.of("hello", "world");

         // Using instance method reference on a class
         List<String> upperCaseWords = words.stream()
                                            .map(String::toUpperCase) // Calling toUpperCase() on each string
                                            .collect(Collectors.toList());

         System.out.println(upperCaseWords);
     }
 }
 üñ• Output:

 [HELLO, WORLD]
 üîπ Key Points:
 String::toUpperCase is a reference to an instance method.
 No specific object is provided; Java applies it to each element in the stream.
 Syntax: ClassName::instanceMethod.


 üöÄ When to Use Which?
 ‚úî Use static method reference when calling a utility/helper method (e.g., Math::max).
 ‚úî Use instance method reference when working with an already created object.
 ‚úî Use class instance method reference when calling methods on stream elements (String::toUpperCase).


 ---------------------------------------------------------------------------------------

Both statements create a list, but they have key differences in mutability and flexibility.

1Ô∏è‚É£ Using new ArrayList<>(Arrays.asList(1,2,3,4))

List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));

‚úÖ Mutable (e.g., add(), remove(), etc.).
‚úÖdynamically resizable.

2Ô∏è‚É£ Using Arrays.asList(...) directly

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

‚ö† Partially mutable:
‚úÖ You can modify elements (set(index, value)).
‚ùå But you cannot add or remove elements (add(), remove(), etc.), because it's a fixed-size list.
This happens because Arrays.asList() returns a fixed-size list backed by the original array.
It is not a full ArrayList, but rather an internal static class (Arrays$ArrayList),
which does not support structural modifications.


Why is Arrays.asList() partially mutable but not resizable?
Arrays.asList() creates a fixed-size list wrapper around an array.
The underlying array is still mutable, so set(index, value) works, but resizing (add() / remove()) is not
allowed because it would require changing the size of the underlying array, which is not supported.

Example to Show the Difference

        List<Integer> list1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        List<Integer> list2 = Arrays.asList(1, 2, 3, 4, 5);

        list1.add(6); // ‚úÖ Works
        System.out.println("list1 after add: " + list1);

        // list2.add(6); // ‚ùå UnsupportedOperationException
        // list2.remove(1); // ‚ùå UnsupportedOperationException

        list2.set(0, 10); // ‚úÖ Works (modifying existing element)
        System.out.println("list2 after modification: " + list2);
    }
}

--------------------------------------------
 Breakdown of Your Code

List<String> locationsLength = locations.stream()
                       .map(x -> x + " " + x.length()) // `x.length()` is an int
                          .collect(Collectors.toList());

             System.out.println(locationsLength);
             x is a String.
             x.length() returns an int.
             x + " " + x.length():
             Since at least one operand is a String, Java automatically converts (x.length()) into a String.
             The result is a new String that contains both the original string and its length.



1. What is Stream API, and why is it used? and explain FUNCTIONAL PROGRAMMING?

The Java Stream API (introduced in Java 8) processes collections efficiently, enabling operations like
filtering, mapping, and reducing in a more concise and readable way.

Purpose of Stream API:

The Stream API brings FUNCTIONAL PROGRAMMING CONCEPTS LIKE MAP, FILTER, REDUCE, AND FOREACH into Java.

Supports LAZY EVALUATION in which intermediate operations (like map() and filter()) are not executed
immediately but only when a terminal operation (collect(), forEach(), etc.) is invoked, improving performance.

ENABLES PARALLEL PROCESSING with parallelStream().
Helps in writing clean and less error-prone code.

How it Helps with Functional Programming:

Example:
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Using Stream API to filter names starting with 'A' and print them
names.stream()
     .filter(name -> name.startsWith("A"))
     .forEach(System.out::println);

------------------------------------------------------------------

1(a). What is Functional Programming?
Here we use functions to PROCESS DATA WITHOUT CHANGING IT DIRECTLY. It avoids modifying variables and
relies on pure functions and reusable functions that can be passed around like data.

Key Features of Functional Programming in Java:

a).PURE FUNCTIONS‚Üí Functions that do not modify state and return the same output for the same input.
E.g : public static int square(int n) {
        return n * n;  // Always returns the same result for the same input
    }

b.)IMMUTABILITY ‚Üí Avoids changing existing data, focusing on creating new copies.

c.)HIGHER ORDER FUNCTIONS ‚Üí Functions that accept other functions as arguments or return them.

E.g: public class Main {
         public static void main(String[] args) {
             Function<Integer, Integer> square = n -> n * n;  // Function to square a number
             // Function functional interface
             System.out.println(applyFunction(5, square));    // Output: 25
         }

         public static int applyFunction(int n, Function<Integer, Integer> square) {
             return square.apply(n);  // Calls the passed function
         }
     }
     ‚úÖ applyFunction() is a higher-order function because it takes another function (square) as an argument.

     EXAMPLE 2:

     import java.util.function.*;

     public class Main {
         public static void main(String[] args) {
             // 1Ô∏è‚É£ Function: Square a number
             Function<Integer, Integer> square = n -> n * n;
             System.out.println("Function (Square of 5): " + applyFunction(5, square));  // Output: 25

             // 2Ô∏è‚É£ Predicate: Check if a number is even
             Predicate<Integer> isEven = n -> n % 2 == 0;
             System.out.println("Predicate (Is 10 even?): " + testPredicate(10, isEven));  // Output: true

             // 3Ô∏è‚É£ Supplier: Generate a random number
             Supplier<Double> randomSupplier = () -> Math.random();
             System.out.println("Supplier (Random number): " + getSupplierValue(randomSupplier));

             // 4Ô∏è‚É£ Consumer: Print a message
             Consumer<String> messagePrinter = msg -> System.out.println("Consumer: " + msg);
             consumeValue("Hello from Consumer!", messagePrinter);
         }

         // ‚úÖ High Order Function for Function<T, R>
         public static int applyFunction(int n, Function<Integer, Integer> func) {
             return func.apply(n);
         }

         // ‚úÖ High Order Function for Predicate<T>
         public static boolean testPredicate(int n, Predicate<Integer> predicate) {
             return predicate.test(n);
         }

         // ‚úÖ High Order Function for Supplier<T>
         public static double getSupplierValue(Supplier<Double> supplier) {
             return supplier.get();
         }

         // ‚úÖ High Order Function for Consumer<T>
         public static void consumeValue(String msg, Consumer<String> consumer) {
             consumer.accept(msg);
         }
     }


d.)Declarative Style ‚Üí Focuses on what to do rather than how to do it.

Example of Functional Programming in Java:

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> doubledNumbers = numbers.stream()
                                      .map(n -> n * 2)  // Pure function
                                      .collect(Collectors.toList());

System.out.println(doubledNumbers); // Output: [2, 4, 6, 8, 10]
üîπ No loops, no modifications to original data, and clean declarative style!

2. Difference between Collection and Stream in Java?

Feature                 Collection	                                Stream
Definition	            Stores and manages elements	                Processes elements in a functional manner
Modification	        Supports adding/removing elements	        Does not modify the original data
Reusability	            Can be iterated multiple times	            Can only be consumed once
Evaluation	            Eager (all elements available immediately)	Lazy (processed only when required)
Parallel Processing 	Not built-in	                             Supports parallel execution with parallelStream()
Type of Operations	    Mutable operations (add, remove)	        Immutable operations (map, filter, reduce)

Example:

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Collection stores elements
numbers.add(6);  // Allowed

// Stream processes data, but original list remains unchanged
Stream<Integer> stream = numbers.stream().map(n -> n * 2);

üîπ KEY TAKEAWAY: COLLECTIONS ARE DATA CONTAINERS, WHILE STREAMS ARE DATA PROCESSORS.



3. How to create a Stream in Java?

1Ô∏è‚É£ Using stream() from Collections
Best for: When working with List, Set, or other collections.
Example:

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        Stream<String> nameStream = names.stream(); // Creating a stream from a List
        nameStream.forEach(System.out::println); // Print each name
    }
}
Properties:
Derived from an existing collection (e.g., List, Set, Queue).
Supports sequential and parallel execution (stream() vs parallelStream()).
Cannot be reused once processed.

2Ô∏è‚É£ Using Stream.of()
Best for: Creating a stream from fixed values or arrays.

Example:

import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {
        Stream<String> stream = Stream.of("Apple", "Banana", "Cherry");
        stream.forEach(System.out::println);
    }
}
Properties:
Can accept varargs (Stream.of(1, 2, 3)) or an array (Stream.of(array)).


3Ô∏è‚É£ Using Stream.iterate()
‚úÖ Best for: Creating a sequential infinite stream based on a function.

Example: Generate first 5 even numbers
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {
        Stream.iterate(2, n -> n + 2) // Start at 2, generate next by adding 2
              .limit(5) // Limit to 5 elements
              .forEach(System.out::println);
    }
}
Properties:
Generates an infinite stream unless explicitly limited (limit(n)).
Sequential by default, but can be parallelized.
Can be used for number sequences, Fibonacci series, etc.

4Ô∏è‚É£ Using Stream.generate()
‚úÖ Best for: Creating an infinite stream using a Supplier function.

Example: Generate 5 random numbers

import java.util.stream.Stream;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        Stream.generate(() -> new Random().nextInt(100)) // Generate random numbers
              .limit(5) // Limit to 5 numbers
              .forEach(System.out::println);
    }
}
Properties:
Generates an infinite stream, so must be limited (limit(n)).
Uses a Supplier function (() -> value) to generate elements.
Each call to generate() does NOT depend on the previous value.
Useful for random values, UUIDs, timestamps, etc.

üî• Quick Interview Summary Table
Method	                Use Case	                                                     Properties
stream()               	Best for processing collections (List, Set, etc.)        	 Read-only processing, does NOT modify original collection, supports parallel execution
Stream.of()	            Best for fixed values (Stream.of(1, 2, 3))	                 Immutable, does NOT create a mutable list, accepts varargs & arrays
Stream.iterate()	    Generates infinite sequences (e.g., 2, 4, 6...)	              Computes each value based on the previous one, needs limit() to avoid infinite loops
Stream.generate()	    Generates random or arbitrary values (UUIDs, random numbers)	Uses a Supplier function, each call is independent, needs limit() to control output


Difference between iterate() and generate()?

iterate(seed, function) ‚Üí Computes the next value based on the previous one.

generate(supplier) ‚Üí Each value is independent (random values, timestamps, etc.).

Which stream method is best for random data?
‚úÖ Stream.generate(() -> new Random().nextInt())

4Ô∏è. Can You Modify Elements Inside a Stream?
No, Streams are immutable, meaning they do not modify the original data. Instead, they create a new stream with transformed elements.
Use map() to transform elements instead of modifying them.

5. Difference Between map() and flatMap()
Feature	              map()	                                   flatMap()
Purpose	             Transforms each element individually	   Flattens and transforms nested structures
Return Type	         Returns Stream<T> for each element        Returns a flattened Stream<T>
Use Case	         Modify elements (e.g., square numbers)	   Flatten lists inside a list

Example: map() vs flatMap()
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<List<Integer>> nestedList = Arrays.asList(
            Arrays.asList(1, 2),
            Arrays.asList(3, 4)
        );


        List<Stream<Integer>> mapResult = nestedList.stream()         // Using map() ‚Üí Returns List<Stream<Integer>>
                                                    .map(List::stream)
                                                    .collect(Collectors.toList());

        List<Integer> flatMapResult = nestedList.stream()            // Using flatMap() ‚Üí Returns List<Integer> (Flattened)

                                                .flatMap(List::stream)
                                                .collect(Collectors.toList());

        System.out.println(flatMapResult); // Output: [1, 2, 3, 4]
    }
}


6Ô∏è‚É£ How Does filter() Work in Streams?
filter() is an intermediate operation in Java Streams that selects elements based on a given condition.

üîπ Key Characteristics:
Uses a Predicate (filter(Predicate<T> condition)) to test each element.
Returns a new Stream containing only elements that pass the condition.

 7. forEach() in Java Streams
‚úÖ Purpose: Used for iteration .
‚úÖ Returns: void
‚úÖ Use Case: Best for iterating elements in a declarative way instead of using a loop.

Example: Using forEach() to Print Elements
import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Using forEach() to print names
        names.forEach(System.out::print);  //üîπ Output : Alice  Bob  Charlie

    }
}


8Ô∏è‚É£ How to Sort a List Using Stream API?

Java's Stream API provides the sorted() method to sort elements in a List. It supports:
1Ô∏è‚É£ Natural Sorting (default order) using sorted().
2Ô∏è‚É£ Custom Sorting using sorted(Comparator).

a.) Sorting Using Natural Order (Comparable)
Works for elements implementing Comparable (e.g., String, Integer).

        // Sorting in natural order (ascending)
        List<Integer> sortedNumbers = numbers.stream()
                                             .sorted()
                                             .collect(Collectors.toList());

// default, sorted() sorts in ascending order for Comparable types.

b.) Sorting Using Custom Comparator (Comparator)
‚úÖ Useful for sorting in custom order, such as descending.

import java.util.Comparator;

        // Sorting in descending order using Comparator
        List<Integer> sortedDesc = numbers.stream()
                                          .sorted(Comparator.reverseOrder())
                                          .collect(Collectors.toList());

üîπ Custom comparators allow more flexibility, such as descending order sorting.

c.) Sorting Objects Using Custom Comparator
‚úÖ Sorting a list of objects based on a field (e.g., sorting Employees by salary).

class Employee {
    String name;
    int salary;

    Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return name + " - " + salary;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 50000),
            new Employee("Bob", 70000),
            new Employee("Charlie", 60000)
        );

        // Sorting employees by salary (ascending)
        List<Employee> sortedEmployees = employees.stream()
                                                  .sorted(Comparator.comparing(emp -> emp.salary))
                                                  .collect(Collectors.toList());

        System.out.println(sortedEmployees);
    }
}
üîπ Output: [Alice - 50000, Charlie - 60000, Bob - 70000]

üöÄ Key Takeaways:
‚úî sorted()                                without arguments ‚Üí Natural order sorting (for Comparable types).
‚úî sorted(Comparator.reverseOrder())       ‚Üí Descending order sorting.
‚úî sorted(Comparator.comparing())          ‚Üí Sort objects based on a specific field.

9Ô∏è‚É£ Terminal vs. Intermediate Operations in Stream API
Java Streams support two types of operations:

Feature	                 Intermediate Operations	                                 Terminal Operations
Definition	            Transforms a stream, returning another stream	              Produces a result (non-stream) or a side effect
Execution	            Lazy (executed only when a terminal operation is called)	  Eager (triggers processing of stream)
Reusability	            returns another stream, allowing method chaining.	          Ends the stream, cannot be reused
Examples	             map(), filter(), sorted(), distinct()	                      forEach(), collect(), count(), reduce()

üîπ Example of Intermediate Operations:
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        // Intermediate operations: filter() and map()
        Stream<String> filteredNames = names.stream()
                                            .filter(name -> name.length() > 3)  // Only names > 3 letters
                                            .map(String::toUpperCase);         // Convert to uppercase

        // Stream is NOT processed yet (lazy evaluation)

üöÄ Nothing prints! The stream is not processed until a terminal operation is applied.

b.) Terminal Operations (Triggers Execution & Ends Stream)
üîπ Example of a Terminal Operation:

        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        // Adding a terminal operation (collect)
        List<String> result = names.stream()
                                   .filter(name -> name.length() > 3)
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());  // Terminal operation

        System.out.println(result);  //üîπ Output:[ALICE, CHARLIE, DAVID]

üöÄ Now the stream processes the elements, as collect() is a terminal operation.

‚úî Common pattern: stream() ‚Üí intermediate ops ‚Üí terminal op.



10. Difference between findFirst() and findAny()?
a.) findFirst() ‚Äì Returns the First Element
‚úÖ Slower in parallel streams due to order constraints

        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        // Using findFirst()
        Optional<String> firstName = names.stream().findFirst();

        firstName.ifPresent(System.out::println);  // Output: Alice


b.) findAny() ‚Äì Returns Any Element (Optimized for Parallel)
‚úÖ More flexible in parallel streams for better performance
‚úÖ May return any element (not necessarily the first)


        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

        // Using findAny()
        Optional<String> anyName = names.parallelStream().findAny();

        anyName.ifPresent(System.out::println);  // Output may vary



   -----------------------------------------------------------------------------------------------------------
 üîπ Intermediate Stream API Questions

1. How does reduce() work in Java Streams?
The reduce() method in Java Streams is a terminal operation used to reduce the stream elements into a single value. It performs a reduction operation such as summing numbers, finding the maximum, or concatenating strings.

Syntax
T reduce(T identity, BinaryOperator<T> accumulator)
identity ‚Äì The initial value.

accumulator ‚Äì A function that combines two elements.

Examples

1Ô∏è‚É£ Sum of all numbers

import java.util.stream.Stream;

public class ReduceExample {
    public static void main(String[] args) {
        int sum = Stream.of(1, 2, 3, 4, 5)
                        .reduce(0, (a, b) -> a + b); // Identity = 0, Accumulator = sum
        System.out.println(sum); // Output: 15
    }
}

2Ô∏è‚É£ Find the maximum value


import java.util.Optional;
import java.util.stream.Stream;

public class ReduceExample {
    public static void main(String[] args) {
        Optional<Integer> max = Stream.of(4, 2, 8, 6)
                                      .reduce(Integer::max);
        System.out.println(max.get()); // Output: 8
    }
}

3Ô∏è‚É£ Concatenating strings


String result = Stream.of("Java", "Streams", "Reduce")
                      .reduce("", (a, b) -> a + " " + b);
System.out.println(result.trim()); // Output: Java Streams Reduce

2. How to count elements in a Stream?
The count() method is a terminal operation that returns the number of elements in the stream.

Example

long count = Stream.of("A", "B", "C", "D").count();
System.out.println(count); // Output: 4

3. What is the difference between collect() and toArray()?
Feature	collect(Collectors.toList())	toArray()
Return Type	List<T>	Object[]
Usage	Converts stream to list	Converts stream to array
Flexibility	Can use different collectors (Set, Map, etc.)	Only returns an array

Example of collect()

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CollectExample {
    public static void main(String[] args) {
        List<String> list = Stream.of("A", "B", "C")
                                  .collect(Collectors.toList());
        System.out.println(list); // Output: [A, B, C]
    }
}
Example of toArray()

Object[] array = Stream.of("A", "B", "C").toArray();
System.out.println(Arrays.toString(array)); // Output: [A, B, C]


4. How to convert a Stream into a Map?
The Collectors.toMap() method is used to convert a stream into a Map.

Example

import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamToMapExample {
    public static void main(String[] args) {
        Map<Integer, String> map = Stream.of("apple", "banana", "cherry")
                                         .collect(Collectors.toMap(String::length, str -> str));
        System.out.println(map); // Output: {5=apple, 6=banana, 6=cherry}
    }
}
Here, the key is the length of the string, and the value is the original string.

5. Explain groupingBy() and partitioningBy() in Collectors
1Ô∏è‚É£ groupingBy() ‚Äì Groups elements based on a classifier function.


import java.util.*;
import java.util.stream.Collectors;

public class GroupingByExample {
    public static void main(String[] args) {
        List<String> words = List.of("apple", "banana", "cherry", "date");
        Map<Integer, List<String>> grouped = words.stream()
                                                 .collect(Collectors.groupingBy(String::length));
        System.out.println(grouped); // Output: {5=[apple], 6=[banana, cherry], 4=[date]}
    }
}
2Ô∏è‚É£ partitioningBy() ‚Äì Splits elements into two groups (true/false).


import java.util.*;
import java.util.stream.Collectors;

public class PartitioningByExample {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);
        Map<Boolean, List<Integer>> partitioned = numbers.stream()
                                                        .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        System.out.println(partitioned); // Output: {false=[1, 3, 5], true=[2, 4, 6]}
    }
}

6. Can you use Stream API with primitive types?
Yes, Java provides primitive specialization streams:

IntStream

LongStream

DoubleStream

Example

import java.util.stream.IntStream;

public class PrimitiveStreams {
    public static void main(String[] args) {
        int sum = IntStream.range(1, 6).sum(); // 1 + 2 + 3 + 4 + 5
        System.out.println(sum); // Output: 15
    }
}

7. What is lazy evaluation in Streams?
Intermediate operations (like map(), filter()) are not executed until a terminal operation (collect(), forEach()) is applied.

This improves performance.

Example

Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5)
                              .filter(n -> {
                                  System.out.println("Filtering " + n);
                                  return n % 2 == 0;
                              });

System.out.println("Before terminal operation");
stream.forEach(System.out::println);
Output

Before terminal operation
Filtering 1
Filtering 2
2
Filtering 3
Filtering 4
4
Filtering 5
Filtering is applied only when needed.

8. Performance Impact: Streams vs Loops
Feature	Streams	Loops
Readability	High	Moderate
Parallel Execution	Yes (parallelStream)	No
Performance	Slight overhead due to lazy evaluation	Faster for simple cases

9. What are Parallel Streams?
parallelStream() enables parallel execution of stream operations.

Improves performance only for large datasets.

Example

import java.util.stream.IntStream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        IntStream.range(1, 10).parallel().forEach(System.out::println);
    }
}

10. What are Short-Circuiting Operations?
These operations terminate early without processing all elements: 1Ô∏è‚É£ limit(n) ‚Äì Stops after n elements.
2Ô∏è‚É£ findFirst() ‚Äì Returns the first matching element. 3Ô∏è‚É£ anyMatch() ‚Äì Returns true if any element matches.

Example

import java.util.stream.Stream;

public class ShortCircuitingExample {
    public static void main(String[] args) {
        Stream.of(1, 2, 3, 4, 5)
              .filter(n -> n % 2 == 0)
              .limit(1)
              .forEach(System.out::println); // Output: 2
    }
}-----------------------------------------------
üí° Bonus: Practical Questions
How to remove duplicates using Stream API?
How to find the second-highest number in a list?
How to merge two lists using Streams?
How to perform pagination using skip() and limit()?

----------------------------------------------------------------------------------

21. What is the difference between findFirst() and findAny() in Java Streams?
findFirst() guarantees the first element; findAny() is optimized for parallel streams.
22. How does skip() work in Stream API?
Skips the first N elements in a Stream.
23. How to find the maximum and minimum values in a list using Streams?
Using max() and min() with a comparator.
24. How to find the sum of all elements in a list using Stream API?
Using reduce() or mapToInt().sum().
25. How to count the occurrences of each word in a list using Stream API?
Using Collectors.groupingBy() with Collectors.counting().
26. How does the peek() method work in Stream API?
Used for debugging or intermediate operations without modifying the Stream.
27. What is the difference between toArray() and collect(Collectors.toList())?
toArray() converts Stream to an array, while collect() gathers elements into a list.
28. How does limit() work in Stream API?
Restricts the Stream to a certain number of elements.
29. What is the purpose of mapToInt(), mapToDouble(), and mapToLong()?
Converts objects into primitive streams for better performance.
30. How do you flatten a List of Lists using Stream API?
Using flatMap().
üîπ Advanced Stream API Questions
31. What are the different ways to create an infinite Stream?
Using Stream.iterate() and Stream.generate().
32. How to use Collectors.joining() to join Strings in a list?
Example of Collectors.joining(", ").
33. How to remove null values from a list using Stream API?
Using filter(Objects::nonNull).
34. What are the benefits of using primitive Streams (IntStream, DoubleStream)?
Discuss memory and performance benefits over wrapper types.
35. How to handle exceptions inside Stream API?
Using try-catch inside map() or using a wrapper method.
36. What is the difference between unordered() and sorted()?
unordered() removes encounter order; sorted() maintains sorting.
37. Why should we avoid using parallel streams with shared mutable state?
Explain thread-safety issues.
38. How does collect(Collectors.partitioningBy()) work?
Splits elements into two groups based on a condition.
39. How to perform pagination using Stream API?
Using skip(offset).limit(pageSize).
40. How to merge two lists into a map using Stream API?
Using Collectors.toMap().
üîπ Expert-Level Stream API Questions
41. How to sort a list of objects using Stream API?
Using sorted() with a comparator.
42. How to find the second-highest number in a list?
Using sorted().skip(n-1).findFirst().
43. How to reverse a Stream?
Using sorted(Comparator.reverseOrder()) or collecting to a list and reversing it.
44. How to convert a Map to a Stream and vice versa?
Using .entrySet().stream() and Collectors.toMap().
45. How to find the first non-repeating character in a String using Streams?
Using Collectors.groupingBy() and filter().
46. Can you use parallelStream() on an array?
Yes, using Arrays.stream(array).parallel().
47. What happens if a Stream operation is executed on a closed Stream?
It throws IllegalStateException.
48. How do you transform a list of objects into a map of objects?
Using Collectors.toMap() with key and value extractors.
49. How does reduce() differ from collect()?
reduce() combines elements into a single value, collect() gathers them into a collection.
50. When should you avoid using Java Streams?
When performance is critical and traditional loops are more efficient.


---------------------------------------------------------------------

Some Extra Questions

1. What are the key features of the Stream API?
Explain functional operations, lazy evaluation, and parallel processing.
2. What is the difference between stream() and parallelStream()?
Discuss how parallelStream() enables multi-threading and when to use it.
3. What is the difference between map() and filter()?
Explain how map() transforms elements while filter() removes unwanted ones.
4. Can we reuse a Java Stream after calling a terminal operation?
Explain why Streams cannot be reused and how to create a new Stream.
5. How do you convert a Stream to an ArrayList?
Using collect(Collectors.toList()).
6. How to convert a List of Strings to uppercase using Stream API?
Example using map() and collect().
7. How to find duplicate elements in a list using Stream API?
Using Collectors.groupingBy() and filtering counts greater than 1.
8. How do you check if all elements in a Stream match a condition?
Using allMatch() method.
9. How to get distinct elements from a Stream?
Using distinct() method.
10. How do you concatenate two Streams in Java?
Using Stream.concat(stream1, stream2).
üîπ Intermediate Stream API Questions
11. What is the difference between findFirst() and findAny() in Java Streams?
findFirst() guarantees first element; findAny() is optimized for parallel streams.
12. How does skip() work in Stream API?
Skips the first N elements in a Stream.
13. How to find the maximum and minimum values in a list using Streams?
Using max() and min() with a comparator.
14. How to find the sum of all elements in a list using Stream API?
Using reduce() or mapToInt().sum().
15. How to count the occurrences of each word in a list using Stream API?
Using Collectors.groupingBy() with Collectors.counting().
16. How does the peek() method work in Stream API?
Used for debugging or intermediate operations without modifying the Stream.
17. What is the difference between toArray() and collect(Collectors.toList())?
toArray() converts Stream to an array, while collect() gathers elements into a list.
18. How does limit() work in Stream API?
Restricts the Stream to a certain number of elements.
19. What is the purpose of mapToInt(), mapToDouble(), and mapToLong()?
Converts objects into primitive streams for better performance.
20. How do you flatten a List of Lists using Stream API?
Using flatMap().
üîπ Advanced Stream API Questions
21. What are the different ways to create an infinite Stream?
Using Stream.iterate() and Stream.generate().
22. How to use Collectors.joining() to join Strings in a list?
Example of Collectors.joining(", ").
23. How to remove null values from a list using Stream API?
Using filter(Objects::nonNull).
24. What are the benefits of using primitive Streams (IntStream, DoubleStream)?
Discuss memory and performance benefits over wrapper types.
25. How to handle exceptions inside Stream API?
Using try-catch inside map() or using a wrapper method.
26. What is the difference between unordered() and sorted()?
unordered() removes encounter order; sorted() maintains sorting.
27. Why should we avoid using parallel streams with shared mutable state?
Explain thread-safety issues.
28. How does collect(Collectors.partitioningBy()) work?
Splits elements into two groups based on a condition.
29. How to perform pagination using Stream API?
Using skip(offset).limit(pageSize).
30. How to merge two lists into a map using Stream API?
Using Collectors.toMap().
üöÄ Bonus: Practical Coding Questions
How to sort a list of objects using Stream API?
How to find the second-highest number in a list?
How to reverse a Stream?
How to convert a Map to a Stream and vice versa?
How to find the first non-repeating character in a String using Streams?